<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="icon" type="image/x-icon" sizes="48x48" href="data:image/x-icon;base64,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">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <link rel="canonical" href="https://copyright.nins.cc/">
  <title translate="no">nins/xy</title>
  
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <style>
    /* åŸºç¤è¨­ç½®ï¼Œé˜²æ­¢å…¨è¢å¹•æº¢å‡º */
    * { box-sizing: border-box; } 

    body { 
      font-family: system-ui, -apple-system, sans-serif; 
      margin: 0; background: #f8fafc; 
      display: flex; flex-direction: column; height: 100vh; overflow: hidden; 
    }

    .toolbar { 
      background: white; 
      padding: 10px 25px; 
      border-bottom: 1px solid #e2e8f0;
      display: flex; 
      flex-direction: column; /* è®“å…§å®¹æ”¹ç‚ºå‚ç›´æ’åˆ—ï¼Œå–ä»£ <br> */
      align-items: center;
      gap: 12px;
    }

    /* é—œéµï¼šæ”¹ç‚ºå‚ç›´æ’åˆ—ä½ˆå±€ */
    #main-layout { 
      display: flex; 
      flex-direction: column; /* ä¸Šä¸‹æ’åˆ— */
      flex: 1; 
      padding: 15px; 
      gap: 15px; 
      overflow: hidden; 
    }

    .view-content {
      flex: 1; 
      width: 100%;
      height: 100%;
      min-height: 0; /* é—œéµï¼šé˜²æ­¢å…§å®¹æ’ç ´ flex å®¹å™¨ */
    }

    /* å€å¡Šå®¹å™¨æ¨£å¼ */
    #blocklyContainer, .card {
      height: 100%;
      width: 100%;
      border: 1px solid #cbd5e1;
      border-radius: 12px;
      background: white;
      box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
      overflow: hidden;
    }

    #blocklyDiv { height: 100%; width: 100%; }
    .card { padding: 10px; display: flex; flex-direction: column; }
    #chart-container { flex: 1; position: relative; min-height: 0; }
    
    button { 
      padding: 8px 16px; border-radius: 8px; border: none; cursor: pointer; font-weight: 600; transition: 0.2s;
    }
    .btn-primary { background: #4f46e5; color: white; }
    
    .tool-group {
      display: flex;         /* å•Ÿç”¨ Flex ä½ˆå±€ */
      gap: 10px;             /* å…ƒç´ ä¹‹é–“çš„é–“è· */
      width: 100%;
      max-width: 600px;      /* é™åˆ¶æœ€å¤§å¯¬åº¦ï¼Œé¿å…åœ¨å¤§è¢å¹•é•·å¾—å¤ªå¥‡æ€ª */
    }
    /* é—œéµï¼šè®“ tool-group å…§çš„æ‰€æœ‰ç›´æ¥å­å…ƒç´ å¹³åˆ†ç©ºé–“ */
    .tool-group > * {
      flex: 1;               /* æ¯ä¸€ä»½å­å…ƒç´ æ¯”ä¾‹çš†ç‚º 1 */
      min-width: 0;          /* é˜²æ­¢å…§å®¹æ’ç ´ flex é …ç›® */
    }
  </style>
</head>
<body translate="no">

<div class="toolbar">
  <div class="tool-group">
    <input type="number" id="Xinput" placeholder="X" oninput="drawAll(Number(document.getElementById('Xinput').value), Number(document.getElementById('Yinput').value))">
    <button style="color: white; background: orange;" onclick="showView('editor')">ğŸ§©</button>
    <button style="color: white; background: #10b981;" onclick="drawAll();showView('chart');">ğŸš€</button>
    <button style="color: white; background: red;" onclick="showView('chart')">ğŸ“Š</button>
    <input type="number" id="Yinput" placeholder="Y" oninput="drawAll(Number(document.getElementById('Xinput').value), Number(document.getElementById('Yinput').value))">
  </div>
  <div class="tool-group" translate="no" style="text-align: center;"> <span>x</span> <span>y</span> <span>z</span> </div>
  <div class="tool-group">
    <!--input type="range" id="minRange" min="-1000" max="-10" value="-20" oninput="drawAll()">
    <input type="range" id="maxRange" min="10" max="1000" value="20" oninput="drawAll()"!-->
    
    <input type="range" id="XRange" min="-1000" max="1000" value="0" step="0.1" oninput="drawAll()">
    <input type="range" id="YRange" min="-1000" max="1000" value="0" step="0.1" oninput="drawAll()">
    <input type="range" id="ZRange" min="0.1" max="10" value="1" step="0.1" oninput="drawAll()">
  </div>


</div>

<div id="main-layout">
  <div id="view-editor" class="view-content">
    <div id="blocklyContainer">
      <div id="blocklyDiv"></div>
    </div>
  </div>

  <div id="view-chart" class="view-content">
    <div class="card">
      <div id="chart-container">
        <canvas id="functionChart"></canvas>
      </div>
    </div>
  </div>
</div>

<xml id="toolbox" style="display:none">
  <category name="All" colour="#777777">
    <block type="point_node">
      <field name="NAME">P</field>
      <value name="X_VAL">
        <shadow type="math_number">
          <field name="NUM">0</field>
        </shadow>
      </value>
      <value name="Y_VAL">
        <shadow type="math_number">
          <field name="NUM">0</field>
        </shadow>
      </value>
    </block>
    <!--block type="point_node"></block!-->
    <block type="start_node"></block>
    <block type="math_single"></block>
    <block type="math_arithmetic"></block>
    <block type="variables_get"><field name="VAR">x</field></block>
    <block type="variables_get"><field name="VAR">y</field></block>
    <block type="math_number"></block>
  </category>
  <!--category name="è®Šæ•¸èˆ‡èµ·é»" colour="#4f46e5">
    <block type="start_node"></block>
    <block type="variables_get"><field name="VAR">x</field></block>
  </category>
  <category name="æ•¸å€¼" colour="#10b981">
    <block type="math_number"></block>
  </category>
  <category name="é‹ç®—" colour="#f59e0b">
    <block type="math_arithmetic"></block>
    <block type="math_single"></block>
  </category!-->
</xml>

<script>
  // è¦–åœ–é¡¯ç¤ºé‚è¼¯
  function showView(viewName) {
    const editor = document.getElementById('view-editor');
    const chartView = document.getElementById('view-chart');

    if (viewName === 'editor') {
      editor.style.display = 'block';
      chartView.style.display = 'none';
      setTimeout(() => Blockly.svgResize(workspace), 50);
    } else {
      editor.style.display = 'none';
      chartView.style.display = 'block';
      drawAll();
    }
  }

  // Blockly å®šç¾©
  ///Blockly.Msg["math_single"] = "ğŸ“ŒA";
  ///Blockly.Msg["math_arithmetic"] = "ğŸ“ŒB";
  Blockly.Blocks['point_node'] = {
    init: function() {
      this.appendDummyInput()
          .appendField("")  ///ğŸ“Œ
          .appendField(new Blockly.FieldTextInput("P"), "NAME");
      this.appendValueInput("X_VAL").setCheck("Number").appendField("x =");
      this.appendValueInput("Y_VAL").setCheck("Number").appendField("y =");
      this.setColour(0); // è¨­å®šç‚ºç´…è‰²å€åˆ¥æ–¼å‡½æ•¸
    }
  };
  /*
  Blockly.Blocks['start_node'] = {
    init: function() {
      this.appendDummyInput().appendField(new Blockly.FieldTextInput("f"), "NAME").appendField("(x)");
      this.appendValueInput("CONTENT").setCheck("Number").appendField("y = ");
      this.setColour(260);
    }
  };  */
  Blockly.Blocks['start_node'] = {
  init: function() {
    this.appendDummyInput()
        .appendField(new Blockly.FieldTextInput("f"), "NAME")
        // é€™è£¡å¯ä»¥æ ¹æ“šæ¨¡å¼é¡¯ç¤º (x) æˆ– (y)
        ///.appendField("(")
        ///.appendField(new Blockly.FieldDropdown([["x", "X"], ["y", "Y"]]), "INPUT_VAR")
        ///.appendField(")");

    this.appendValueInput("CONTENT")
        .setCheck("Number")
        .appendField(new Blockly.FieldDropdown([["y =", "Y_EQ"], ["x =", "X_EQ"]]), "MODE");
    this.setColour(260);
  }
};

  const workspace = Blockly.inject('blocklyDiv', {
    toolbox: document.getElementById('toolbox'),
    grid: { spacing: 20, length: 3, colour: '#f1f5f9', snap: true },
    renderer: 'zelos'
  });

  function evaluate(block, scope) {  ///x=>>scope
    if (!block) return null;
    const type = block.type;

    ///if (type === 'variables_get') return x;
    if (type === 'variables_get') {
      const varId = block.getFieldValue('VAR');
      const varName = workspace.getVariableById(varId).name; // å–å¾—è®Šæ•¸åç¨± "x" æˆ– "y"
      return scope[varName] || 0; // å›å‚³å°æ‡‰çš„æ•¸å€¼
    }
    
    if (type === 'math_number') return Number(block.getFieldValue('NUM'));
    
    if (type === 'math_arithmetic') {
      ///const a = evaluate(block.getInputTargetBlock('A'), x);
      ///const b = evaluate(block.getInputTargetBlock('B'), x);
      const a = evaluate(block.getInputTargetBlock('A'), scope);
      const b = evaluate(block.getInputTargetBlock('B'), scope);
      const op = block.getFieldValue('OP');
      if (a === null || b === null) return null;
      switch(op) {
        case 'ADD': return a + b;
        case 'MINUS': return a - b;
        case 'MULTIPLY': return a * b;
        case 'DIVIDE': return b === 0 ? 0 : a / b;
        case 'POWER': return Math.pow(a, b);
      }
    }
    // ... math_single é‚è¼¯çœç•¥ ...
    // --- é—œéµï¼šæ–°å¢å° math_single çš„æ”¯æ´ ---
    if (type === 'math_single') {
      ///const arg = evaluate(block.getInputTargetBlock('NUM'), x);
      const arg = evaluate(block.getInputTargetBlock('NUM'), scope);
      const op = block.getFieldValue('OP');
      if (arg === null) return null;
      switch (op) {
        case 'ROOT': return Math.sqrt(arg);
        case 'ABS': return Math.abs(arg);
        case 'NEG': return -arg;
        case 'LN': return Math.log(arg);
        case 'LOG10': return Math.log10(arg);
        case 'EXP': return Math.exp(arg);
        case 'POW10': return Math.pow(10, arg);
        case 'SIN': return Math.sin(arg); // é€™è£¡è™•ç† sin(x)
        case 'COS': return Math.cos(arg);
        case 'TAN': return Math.tan(arg);
        default: return arg;
      }
    }
    return null;
  }

  function blockToText(block) {  // 20260103#1
    if (!block) return "";
    const type = block.type;

    if (type === 'variables_get') {
      const varId = block.getFieldValue('VAR');
      return workspace.getVariableById(varId).name; // å›å‚³ "x" æˆ– "y"
    }
    
    if (type === 'math_number') return block.getFieldValue('NUM');
    
    if (type === 'math_arithmetic') {
      const a = blockToText(block.getInputTargetBlock('A'));
      const b = blockToText(block.getInputTargetBlock('B'));
      const op = block.getFieldValue('OP');
      const opMap = { 'ADD': '+', 'MINUS': '-', 'MULTIPLY': '*', 'DIVIDE': '/', 'POWER': '^' };
      return `(${a} ${opMap[op]} ${b})`;
    }

    if (type === 'math_single') {
      const arg = blockToText(block.getInputTargetBlock('NUM'));
      const op = block.getFieldValue('OP');
      return `${op.toLowerCase()}(${arg})`;
    }
    return "";
  }

  let chart = null;
  function drawAll(Xinput=null, Yinput=null) {
    const startBlocks = workspace.getBlocksByType('start_node');

    const Xbase = Xinput !== null ? Number(Xinput) : Number(document.getElementById('XRange').value);
    const Ybase = Yinput !== null ? Number(Yinput) : Number(document.getElementById('YRange').value);
    const Zbase = Number(document.getElementById('ZRange').value);

    // é—œéµä¿®æ­£ï¼šå¼·åˆ¶è½‰ç‚º Number ä»¥å…è®Šæˆå­—ä¸²æ‹¼æ¥
    const minX = Xbase - 20*Zbase;
    const maxX = Xbase + 20*Zbase;
    const minY = Ybase - 20*Zbase;
    const maxY = Ybase + 20*Zbase;

    if (Xinput===null) {
      document.getElementById('Xinput').value = document.getElementById('XRange').value
      document.getElementById('Yinput').value = document.getElementById('YRange').value
    } else {
      document.getElementById('XRange').value = document.getElementById('Xinput').value
      document.getElementById('YRange').value = document.getElementById('Yinput').value
    }
    
    const xValues = [];
    // å‹•æ…‹è¨ˆç®—æ­¥é•·ä»¥ç¶­æŒæ•ˆèƒ½
    const step = (maxX - minX) / 500; // æé«˜æ¡æ¨£ç‡

    for (let i = minX; i <= maxX; i += step) {
      xValues.push(Number(i.toFixed(2)));
    }

    const datasets = [];
    const colorPalette = ['#4f46e5', '#10b981', '#f59e0b', '#ef4444'];
    /*
    startBlocks.forEach((startBlock, index) => {
      const target = startBlock.getInputTargetBlock('CONTENT');
      if (!target) return;
      const funcName = startBlock.getFieldValue('NAME');
      const yValues = xValues.map(x => evaluate(target, x));
      datasets.push({
        label: `${funcName}(x)`,
        data: yValues,
        borderColor: colorPalette[index % colorPalette.length],
        borderWidth: 2,
        pointRadius: 0,
        tension: 0.2
      });
    });  */
    startBlocks.forEach((startBlock, index) => {
      const target = startBlock.getInputTargetBlock('CONTENT');
      if (!target) return;

      const mode = startBlock.getFieldValue('MODE'); // 'Y_EQ' æˆ– 'X_EQ'
      const funcName = startBlock.getFieldValue('NAME');  // 20260103#1
      const formula = blockToText(target); // å–å¾—å…¬å¼å­—ä¸²  // 20260103#1
      const fullLabel = mode === 'Y_EQ' ? `${funcName}(x): y = ${formula}` : `${funcName}(y): x = ${formula}`;  // 20260103#1

      const dataPoints = [];

      if (mode === 'Y_EQ') {
        // å‚³çµ± y = f(x)
        for (let i = minX; i <= maxX; i += step) {
          const val = evaluate(target, { x: i, y: 0 }); // æ­¤æ™‚ y é€šå¸¸ä¸å½±éŸ¿çµæœ
          dataPoints.push({ x: i, y: val });
        }
      } else {
        // æ–°å¢ x = f(y)
        // é€™è£¡æ”¹ç”± y è»¸ç¯„åœé€²è¡Œç–Šä»£
        const yStep = (maxY - minY) / 100;
        for (let j = minY; j <= maxY; j += yStep) {
          const val = evaluate(target, { x: 0, y: j }); // è¨ˆç®— x çš„å€¼
          dataPoints.push({ x: val, y: j }); // æ³¨æ„ï¼šx æ˜¯ç®—å‡ºä¾†çš„ï¼Œy æ˜¯è‡ªè®Šé‡
        }
      }

      datasets.push({
        ///label: startBlock.getFieldValue('NAME'),
        label: fullLabel,  // 20260103#1
        data: dataPoints, // Chart.js æ”¯æ´ {x: , y: } æ ¼å¼çš„æ•¸æ“šç‰©ä»¶
        borderColor: colorPalette[index % colorPalette.length],
        showLine: true,
        borderWidth: 2,
        ///pointRadius: 0, // é€™è£¡æ”¹ç‚º 0 å°±ä¸æœƒçœ‹åˆ°å½©è‰²é»äº†***
        tension: 0.2,
        order: 2, // å‡½æ•¸å±¤ç´šè¨­ç‚º 2 (è¼ƒå¾Œæ–¹)
      });
    });

    ///==== æ’å…¥é»ç¹ªåœ– ==============================
    // è™•ç†é»çš„æ¨™è¨˜
    const pointBlocks = workspace.getBlocksByType('point_node');
    pointBlocks.forEach((pointBlock, index) => {
      const xTarget = pointBlock.getInputTargetBlock('X_VAL');
      const yTarget = pointBlock.getInputTargetBlock('Y_VAL');
      
      if (!xTarget || !yTarget) return;

      const px = evaluate(xTarget, { x: 0, y: 0 });
      const py = evaluate(yTarget, { x: 0, y: 0 });
      const pName = pointBlock.getFieldValue('NAME');

      datasets.push({
        label: pName,
        data: [{ x: px, y: py }],
        backgroundColor: '#ffffff', // é»çš„é¡è‰²
        borderColor: '#000000',
        pointRadius: 8,             // è®“é»è®Šå¤§æ˜é¡¯
        pointHoverRadius: 8,
        showLine: false,             // é‡è¦ï¼šä¸é€£æˆç·š
        order: 1, // å‡½æ•¸å±¤ç´šè¨­ç‚º 2 (è¼ƒå¾Œæ–¹)
      });
    });
    ///==== æ’å…¥é»ç¹ªåœ– ==============================

    const ctx = document.getElementById('functionChart').getContext('2d');
    if (chart) chart.destroy();
    chart = new Chart(ctx, {
      type: 'line',
      data: { labels: xValues, datasets: datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false, // è®“æ‹‰å‹• Slider æ™‚æ›´æµæš¢
        scales: {
          x: {
            type: 'linear', // å¼·åˆ¶ X è»¸ç‚ºæ•¸å€¼ç·šï¼Œè€Œéæ¨™ç±¤
            position: 'bottom',
            min: minX,
            max: maxX
          },
          y: {
            type: 'linear',
            min: minY,
            max: maxY
          }
          ///x: { grid: { display: false } },
          ///y: { beginAtZero: false, min: minY, max: maxY, }
        },
        interaction: {
          mode: 'index',     // æ»‘é¼ é è¿‘ X è»¸æ™‚ï¼Œé¡¯ç¤ºè©² X è»¸ä¸Šã€Œæ‰€æœ‰ã€æ•¸æ“š
          intersect: false,  // ä¸éœ€è¦æ»‘é¼ ç›´æ¥æŒ‡åˆ°é»ä¸Šå°±èƒ½é¡¯ç¤º
        },plugins: {
          tooltip: {
            enabled: true,
            backgroundColor: 'rgba(0, 0, 0, 0.8)', // æç¤ºæ¡†èƒŒæ™¯è‰²
            padding: 10,
            callbacks: {
              // åœ¨æç¤ºæ¡†æ¨™é¡Œé¡¯ç¤º X å€¼
              title: function(context) {
                return 'x = ' + context[0].label;
              },
              // é¡¯ç¤ºå„å‡½æ•¸çš„ Y å€¼
              label: function(context) {
                let label = context.dataset.label || '';
                if (label) {
                  label += ': ';
                }
                if (context.parsed.y !== null) {
                  label += context.parsed.y.toFixed(2); // é¡¯ç¤ºå…©ä½å°æ•¸
                }
                return label;
              }
            }
          }
        },
      }
    });
  }
function init() {
  const variableX = workspace.getVariable('x') || workspace.createVariable('x');
  const variableY = workspace.getVariable('y') || workspace.createVariable('y');

  // --- å‡½æ•¸ 1: f(x) = x * x ---
  const startF = workspace.newBlock('start_node');
  startF.setFieldValue('f', 'NAME');
  startF.initSvg(); startF.render(); startF.moveBy(20, 20);

  const mul = workspace.newBlock('math_arithmetic');
  mul.setFieldValue('MULTIPLY', 'OP');
  mul.initSvg(); mul.render();

  const x1 = workspace.newBlock('variables_get');
  x1.setFieldValue(variableX.getId(), 'VAR');
  const x2 = workspace.newBlock('variables_get');
  x2.setFieldValue(variableX.getId(), 'VAR');

  x1.initSvg(); x1.render();
  x2.initSvg(); x2.render();

  mul.getInput('A').connection.connect(x1.outputConnection);
  mul.getInput('B').connection.connect(x2.outputConnection);
  startF.getInput('CONTENT').connection.connect(mul.outputConnection);

  // --- å‡½æ•¸ 2: g(x) = sin(x) ---
  const startG = workspace.newBlock('start_node');
  startG.setFieldValue('g', 'NAME');
  startG.initSvg(); startG.render(); startG.moveBy(20, 150); // å¾€ä¸‹ä½ç§»ï¼Œé¿å…é‡ç–Š

  const sinBlock = workspace.newBlock('math_single');
  sinBlock.setFieldValue('SIN', 'OP');
  sinBlock.initSvg(); sinBlock.render();

  const x3 = workspace.newBlock('variables_get');
  x3.setFieldValue(variableX.getId(), 'VAR');
  x3.initSvg(); x3.render();

  sinBlock.getInput('NUM').connection.connect(x3.outputConnection);
  startG.getInput('CONTENT').connection.connect(sinBlock.outputConnection);


  // --- å…§å»ºåˆå§‹åŒ– y = 0 ---
  /*
  const startY0 = workspace.newBlock('start_node');
  startY0.setFieldValue('y0', 'NAME');
  startY0.setFieldValue('Y_MODE', 'MODE'); // è¨­å®šæ¨¡å¼ç‚º y =
  startY0.initSvg(); startY0.render(); startY0.moveBy(50, 50);
  const num0 = workspace.newBlock('math_number');
  num0.setFieldValue('0', 'NUM');
  num0.initSvg(); num0.render();
  startY0.getInput('CONTENT').connection.connect(num0.outputConnection);  */

  // --- å‡½æ•¸ 3: h(x) = x * x * x ---
  const startH = workspace.newBlock('start_node');
  startH.setFieldValue('h', 'NAME');

  // 1. å»ºç«‹ä¹˜æ³•èˆ‡è®Šæ•¸ç©æœ¨
  const mulH1 = workspace.newBlock('math_arithmetic');
  mulH1.setFieldValue('MULTIPLY', 'OP');
  const mulH2 = workspace.newBlock('math_arithmetic');
  mulH2.setFieldValue('MULTIPLY', 'OP');

  const x4 = workspace.newBlock('variables_get');
  x4.setFieldValue(variableX.getId(), 'VAR');
  const x5 = workspace.newBlock('variables_get');
  x5.setFieldValue(variableX.getId(), 'VAR');
  const x6 = workspace.newBlock('variables_get');
  x6.setFieldValue(variableX.getId(), 'VAR');

  // 2. é—œéµï¼šå°æ‰€æœ‰ç©æœ¨åŸ·è¡Œ initSvg (å¦å‰‡é€£ç·šåº§æ¨™æœƒå‡ºéŒ¯)
  [startH, mulH1, mulH2, x4, x5, x6].forEach(b => b.initSvg());

  // 3. é€²è¡Œçµ„è£ (x * x) * x
  mulH1.getInput('A').connection.connect(x4.outputConnection);
  mulH1.getInput('B').connection.connect(x5.outputConnection);
  mulH2.getInput('A').connection.connect(mulH1.outputConnection);
  mulH2.getInput('B').connection.connect(x6.outputConnection);
  startH.getInput('CONTENT').connection.connect(mulH2.outputConnection);

  // 4. æœ€å¾Œæ¸²æŸ“é ‚å±¤ç©æœ¨ï¼Œå®ƒæœƒéè¿´æ¸²æŸ“æ‰€æœ‰å…§åµŒç©æœ¨
  startH.render();

    startH.initSvg(); startH.render();
    startH.moveBy(20, 300); // å†å¾€ä¸‹ç§»å‹•ï¼Œé¿å…é‡ç–Š

    // ç¹ªè£½åˆå§‹åœ–è¡¨
    drawAll();
  }  
  
  // --- å…§å»ºåˆå§‹åŒ–ä¸€å€‹ x = 0 ---
  const startX0 = workspace.newBlock('start_node');
  startX0.setFieldValue('i', 'NAME');
  startX0.setFieldValue('X_EQ', 'MODE'); // è¨­å®šç‚º x = æ¨¡å¼
  startX0.initSvg(); startX0.render(); startX0.moveBy(20, 450);
  const num0 = workspace.newBlock('math_number');
  num0.setFieldValue('0', 'NUM');
  num0.initSvg(); num0.render();
  startX0.getInput('CONTENT').connection.connect(num0.outputConnection);

  
  // åˆå§‹åŒ–
  window.addEventListener('load', () => {
    init();
    ///showView('editor');  // é è¨­é¡¯ç¤ºç·¨è¼¯å™¨
    showView('chart');
    window.addEventListener('resize', () => Blockly.svgResize(workspace));
  });
</script>
</body>

</html>
